---
layout: single
title: WhiteHat 2018 - re07
permalink: /whitehat-re07/
author: true
---

{% include toc %}

This is a challenge from WhiteHat Grand Prix 2018 â€“ Quals.
I wasn't able to find any writeups for this challenge, but I will at least write about what I know about it.

**DISCLAIMER: NOT FINISHED**

# Where to start

We were given a IP + file.
Since I trust myself more in forensics, I started with file.

```sh
vagrant@archlinux:[re07-500]$ file 0955bfcf85d870fe7217d8b6cb2ae576.bin
0955bfcf85d870fe7217d8b6cb2ae576.bin: data
```

It's just data... Luckily `binwalk` found something inside.

```sh
vagrant@archlinux:[re07-500]$ binwalk 0955bfcf85d870fe7217d8b6cb2ae576.bin

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
96            0x60            uImage header, header size: 64 bytes, header CRC: 0x7FE9E826, created: 2010-11-23 11:58:41, image size: 878029 bytes, Data Address: 0x80000000, Entry Point: 0x802B5000, data CRC: 0x7C3CAE85, OS: Linux, CPU: MIPS, image type: OS Kernel Image, compression type: lzma, image name: "Linux Kernel Image"
160           0xA0            LZMA compressed data, properties: 0x5D, dictionary size: 33554432 bytes, uncompressed size: 2956312 bytes
917600        0xE0060         PackImg section delimiter tag, little endian size: 7348736 bytes; big endian size: 2256896 bytes
917632        0xE0080         Squashfs filesystem, little endian, non-standard signature, version 3.0, size: 2318636 bytes, 1121 inodes, blocksize: 65536 bytes, created: 2018-08-12 14:36:03
```

Most interesting thing about this file was **Squashfs** filesystem.
I ran `binwalk` extraction and started looking at internet for documentation.
But when I looked back to terminal, `binwalk` was able to extract everything in the meantime.
So there was no need for mounting the filesystem...

```sh
vagrant@archlinux:[re07-500]$ binwalkbinwalk -eM 0955bfcf85d870fe7217d8b6cb2ae576.bin
# ...
```

## What should I even look for?

There was nothing particularly interesting about the extracted files.
I spend a few minutes randomly reading files and trying to figure out what is relevant.

I found Nothing...

## Recon

Now was the time to look at the given IP(45.77.30.7).

It's XAMPP dashboard, and since I did web stuff a long time ago. I had no clue where to begin.
So I took a break. And then it **struck me**.

Let's check what `nmap` has to say.

```sh
vagrant@archlinux:[_restart.htm.extracted]$ nmap 45.77.30.7
Starting Nmap 7.70 ( https://nmap.org ) at 2018-08-18 14:55 UTC
Nmap scan report for 45.77.30.7.vultr.com (45.77.30.7)
Host is up (0.30s latency).
Not shown: 996 closed ports
PORT      STATE SERVICE
22/tcp    open  ssh
80/tcp    open  http
6969/tcp  open  acmsoda
10010/tcp open  rxapi

Nmap done: 1 IP address (1 host up) scanned in 54.57 seconds
```

Port 6969 was very suspicious. But I didn't want to underestimate others, so I played with all of them.

```sh
vagrant@archlinux:[_restart.htm.extracted]$ nc 45.77.30.7 6969
~\m/~
Pr00f-of-H4rdW0rk
Door is available.
123
Hey commander! I don't understand S/m\S
help
Hey commander! I don't understand S/m\S
```

Finally, something to work with. 6969 was really promising.

Now I grepped for the string and voila, we have a binary.

```sh
vagrant@archlinux:[_0955bfcf85d870fe7217d8b6cb2ae576.bin-1.extracted]$ grep -ra "Door is" .
./shella:%sDoor is unavailable.
./shella:[XXX] Secured Door is %s
./shella: setgetDoor is available.
./_shella.extracted/0.elf:%sDoor is unavailable.
./_shella.extracted/0.elf:[XXX] Secured Door is %s
./_shella.extracted/0.elf: setgetDoor is available.
```

# Analysis

Let's be honest. I ran the `file` command on binary and totally disregarded the information **it was actutally MIPS**.
Opened hopper. Looking few seconds at the weird x86... Opened radare to cross-check if I see right. It was even worse.

My half asleep brain took a while to realize it was actually different architecture.

I used r2 to disassemble the binary and this is what I got so far. Really abstract overview of what is happening.
Without encryption routines. If there is anyone who wants to help and collaborate, I will be really glad.

```c
void main(int argc, char * argv[]) {
    for(;;) {
    	 // listen on the port
	 // fork
	 // thread_func()
    } 
    return 0;
}
```

```c
void thread_func() { // created by fork
    0xe0[4] = {0};
    write(constant);
    if(checkFlag()) {
	// string = Door is available.\n
    } else {
	// string = Door is unavailable.\n
    }
    write(string, strlen(string), socket);
    memset(message_for_user, 0, 200);
    read_size = read(message_for_user, 200, socket);
    if(read_size > 0) {
	if(processMessage(&message_for_user, something) == 0) {
	    message_for_user = "Hey_Commander I dont understand your message"; //...
	}
	write(message_for_user, strlen(message_for_user), socket);
	memset(message_for_user, 0, 200);
    } else {
	if(read_size != 0) {
	    // close and print something prob irelevant
	}
    }
}

void processMessage(char ** user_message, something) {
    int ret = 1;
    message_dup = strdup(message)
    token = strtok(message_dup, "some delim?");

    if(strcmp(token, "set") != 0) {
	if(strcmp(token, "get") != 0) {
	    getFlag(something, user_messsage);
	    ret = 0;
	}
    } else {
	first_token = strtok(NULL, "prob space");
	second_token = strtok(NULL, "prob space");
	if(first_token != NULL && second_token != NULL) {
	    ret = 0;
	    setFlag(sedond_token, first_token, user_message);
	}
    }
    free(message_dup);
    return ret;
}

void getFlag(something, char * user_message) {
    0x28 = something;
    0x2c = user_message;
    if(checkFlag() != 0) {
	flag? = clean(something);
	sprintf(user_message, "[XXX] Secured Door is %s\n", flag?);
	free(flag?);
    } else {
	0x2c = "Door is unavailable.\n";
    }
}

char * clean(int[4] something) {
    flag_copy = malloc(65);
    srand(time(NULL));
    strcpy(flag_copy, obj.flag);

    counter = 0;

    byte r = rand();
    0x24 = strlen(obj.flag);
    byte r1 = rand();
    something[0] = r1;
    something[1] = r1;
    something[2] = r1;
    something[3] = r1;
    r1 += 3;
    if(r1 < 0) {
	r1 += 3;
    }
    r1 /= 2;

    0x28 = r1;
    r1 &= 0xff;
    btea(flag_copy, r1, something);

    r1 = 0x28;
    r1 *= 2;
    for(int counter = 0; counter < r1; counter++) {
	if(flag_copy[counter]) {
	    flag_copy[counter] = flag_copy[counter] ^ r & 0xff;
	}
    }
    flag_copy[r1*2] = '\0';
    return flag_copy;
}

void btea(char * flag_copy, byte num, something_arr) {
    0x30 = flag_copy;
    0x38 = something_arr;
    0x34 = num;
    // flag_copy[(num + 0x3fffffff) * 2]
    // ...
}

loadFlag() {
    fread(obj.flag, 1, 61, 'flag');
    fclose('flag');
}

int checkFlag(char *flag?) {
    loadFlag();

    if(obj.flag != null) {
	return 1;
    } else {
	return 0;
    }
}
```
